<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xml" href="http://www.gadom.ski/feed.xslt.xml"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.3.1">Jekyll</generator><link href="http://www.gadom.ski/feed.xml" rel="self" type="application/atom+xml" /><link href="http://www.gadom.ski/" rel="alternate" type="text/html" /><updated>2017-01-23T09:57:38-07:00</updated><id>http://www.gadom.ski//</id><title type="html">LiDAR :: snow :: ice :: code</title><subtitle>I do research, code development, and field work for CRREL.
</subtitle><entry><title type="html">Slope maps with GMT</title><link href="http://www.gadom.ski/gmt/2017/01/23/slope-maps-with-gmt.html" rel="alternate" type="text/html" title="Slope maps with GMT" /><published>2017-01-23T00:00:00-07:00</published><updated>2017-01-23T00:00:00-07:00</updated><id>http://www.gadom.ski/gmt/2017/01/23/slope-maps-with-gmt</id><content type="html" xml:base="http://www.gadom.ski/gmt/2017/01/23/slope-maps-with-gmt.html">&lt;p&gt;About two-thirds of dry slab avalanches occur on slopes between 30° and 45° &lt;a href=&quot;#McClung2006&quot;&gt;(McClung &amp;amp; Schaerer, 2006)&lt;/a&gt;.
A map of slope angles is therefore a useful tool for safe decision making when backcountry skiing.&lt;/p&gt;

&lt;p&gt;The excellent &lt;a href=&quot;https://caltopo.com/&quot;&gt;CalTopo&lt;/a&gt; provides a suite of map building tools, including a slope angle shading map.
But me being me, I want to make my own maps.&lt;/p&gt;

&lt;p&gt;This wakthrough describes how to make a slope angle shading map using free and open data and &lt;a href=&quot;http://gmt.soest.hawaii.edu/&quot;&gt;Generic Mapping Tools (GMT)&lt;/a&gt;.
You’ll need the following softwares to follow along:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;GMT&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.gdal.org/&quot;&gt;GDAL/OGR&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The Makefile used in this example, along with a download script to fetch the map data, are in a gist at the &lt;a href=&quot;#conclusion&quot;&gt;bottom of this post&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;the-goal&quot;&gt;The goal&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Hidden_Valley_(Ski_Estes_Park)&quot;&gt;Hidden Valley&lt;/a&gt; is a abandoned ski area in Rocky Mountain National Park that closed in 1991.
It now is a popular winter destination for backcountry skiing and sledding.
We want to color-code dangerous slope angles while providing enough additional context to make a useful map.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/hidden-valley-slope-angle.png&quot; alt=&quot;Hidden Valley&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;getting-the-data&quot;&gt;Getting the data&lt;/h2&gt;

&lt;p&gt;We’ll use data from the &lt;a href=&quot;https://nationalmap.gov/elevation.html&quot;&gt;USGS 3D Elevation Program&lt;/a&gt; to produce our slope, hillshade, and contour grids.
Our stream and lake overlays will come from the &lt;a href=&quot;https://nhd.usgs.gov/&quot;&gt;National Hydrography Dataset&lt;/a&gt;, and the roads from the &lt;a href=&quot;https://catalog.data.gov/dataset/usgs-national-transportation-dataset-ntd-downloadable-data-collectionde7d2&quot;&gt;National Transporation Dataset&lt;/a&gt;.
All these products are browsable and downloadable through &lt;a href=&quot;https://viewer.nationalmap.gov/basic/&quot;&gt;The National Map&lt;/a&gt;, but here’s direct links to the datasets required for this exercise:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://prd-tnm.s3.amazonaws.com/StagedProducts/Elevation/13/GridFloat/USGS_NED_13_n40w106_GridFloat.zip&quot;&gt;n40w106&lt;/a&gt; DEM as GridFloat&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://prd-tnm.s3.amazonaws.com/StagedProducts/Elevation/13/GridFloat/USGS_NED_13_n41w106_GridFloat.zip&quot;&gt;n41w106&lt;/a&gt; DEM as GridFloat&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://prd-tnm.s3.amazonaws.com/StagedProducts/Hydrography/NHD/HU8/HighResolution/Shape/NHD_H_10190005_Shape.zip&quot;&gt;Subbasin 10190005&lt;/a&gt; as a shapefile&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://prd-tnm.s3.amazonaws.com/StagedProducts/Tran/Shape/TRAN_8_Colorado_GU_STATEORTERRITORY.zip&quot;&gt;Colorado roads&lt;/a&gt; as a shapefile&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All told, it’s about 4.6G of data, organized like this on my system:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ tree -P '*.shp|*.flt'
.
├── dem
│   ├── n40w106
│   │   └── n40w106.shp
│   ├── n41w106
│   │   └── n41w106.shp
│   ├── usgs_ned_13_n40w106_gridfloat.flt
│   └── usgs_ned_13_n41w106_gridfloat.flt
├── roads
│   └── Shape
│       ├── Trans_AirportPoint.shp
│       ├── Trans_AirportRunway.shp
│       ├── Trans_RailFeature.shp
│       ├── Trans_RoadSegment.shp
│       ├── Trans_RoadSegment2.shp
│       ├── Trans_RoadSegment3.shp
│       └── Trans_TrailSegment.shp
└── water
    └── Shape
        ├── NHDArea.shp
        ├── NHDFlowline.shp
        ├── NHDLine.shp
        ├── NHDPoint.shp
        ├── NHDPointEventFC.shp
        ├── NHDWaterbody.shp
        ├── WBDHU10.shp
        ├── WBDHU12.shp
        ├── WBDHU2.shp
        ├── WBDHU4.shp
        ├── WBDHU8.shp
        └── WBDLine.shp

7 directories, 23 files
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;creating-a-simple-raster-map-with-gmt&quot;&gt;Creating a simple raster map with GMT&lt;/h2&gt;

&lt;p&gt;To prove that our system is working, let’s create a rainbow elevation map from our DEM data in our area of interest.
We’ll use a Makefile and place our generated products in &lt;code class=&quot;highlighter-rouge&quot;&gt;build/&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;First, we define our area of interest and create a rule for our build directory:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;XMIN:=-105.70
XMAX:=-105.62
YMIN:=40.37
YMAX:=40.41

build:
	mkdir $@
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Next, we subset our DEM data to our area of interest using a VRT.
For some reason GMT (on my system) isn’t happy reading VRTs, even though it should be able to use any GDAL-y data source, so we use the VRT to create a GeoTIFF:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;build/dem.vrt: Makefile | build
	gdalbuildvrt -te $(XMIN) $(YMIN) $(XMAX) $(YMAX) $@ $(wildcard dem/*.flt)

build/dem.tif: build/dem.vrt
	gdal_translate $&amp;lt; $@
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Finally, we create our simple rainbow elevation map.
I do this in two steps — first I create the PostScript file, then I use &lt;code class=&quot;highlighter-rouge&quot;&gt;psconvert&lt;/code&gt; to turn it into a png:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;build/hidden-valley.ps: build/dem.tif Makefile | build
	grdimage $&amp;lt; &amp;gt; $@

%.png: %.ps
	psconvert -TG -A -P $&amp;lt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;A few things to note:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;grdimage&lt;/code&gt; takes &lt;em&gt;many&lt;/em&gt; more options, but for now we’re keeping it simple.&lt;/li&gt;
  &lt;li&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;psconvert&lt;/code&gt; command converts the PostScript file into a png with transparency (&lt;code class=&quot;highlighter-rouge&quot;&gt;-TG&lt;/code&gt;), cropped (&lt;code class=&quot;highlighter-rouge&quot;&gt;-A&lt;/code&gt;), and rotated into portrait mode (&lt;code class=&quot;highlighter-rouge&quot;&gt;-P&lt;/code&gt;).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We make our map by running &lt;code class=&quot;highlighter-rouge&quot;&gt;make build/hidden-valley.png&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/hidden-valley-rainbow.png&quot; alt=&quot;Rainbow elevation map of Hidden Valley&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;creating-more-derivative-products&quot;&gt;Creating more derivative products&lt;/h2&gt;

&lt;p&gt;We’ve already created one derivative product, our cropped DEM &lt;code class=&quot;highlighter-rouge&quot;&gt;build/dem.tif&lt;/code&gt;.
Let’s create the rest of the products we need to make our map.
I’ll step through the rules one-by-one and talk through what they’re doing.&lt;/p&gt;

&lt;h3 id=&quot;calculate-the-slope&quot;&gt;Calculate the slope&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;build/slope.nc: build/dem.tif
	grdgradient -fg $&amp;lt; -S$@ -D
	grdmath $@ ATAN PI DIV 180 MUL = $@
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;grdgradient&lt;/code&gt; does derivative math on gridded data.
In this case, we use the combination of the &lt;code class=&quot;highlighter-rouge&quot;&gt;-D&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;-S&lt;/code&gt; options to write the magnitude of the gradient vector to a file, &lt;code class=&quot;highlighter-rouge&quot;&gt;build/slope.nc&lt;/code&gt;.
We also need to specify &lt;code class=&quot;highlighter-rouge&quot;&gt;-fg&lt;/code&gt; because our data is a geographic (lat/lon) grid and we need to convert those latitudes and longitudes to meters before calculating the gradient.
Once we’ve calculated the raw gradient magnitude, we convert that scalar value to an angle, in degrees, using &lt;code class=&quot;highlighter-rouge&quot;&gt;grdmath&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;create-a-hillshade&quot;&gt;Create a hillshade&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;build/gradient.nc: build/dem.tif
	grdgradient -fg $&amp;lt; -G$@ -A-45 -Nt0.6
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;In this case, we use &lt;code class=&quot;highlighter-rouge&quot;&gt;grdgradient&lt;/code&gt; to create a hillshade.
We use &lt;code class=&quot;highlighter-rouge&quot;&gt;-N&lt;/code&gt; to control the intensity of the hillshade — since we’ll be drawing contours and additional overlays, we dial down the intensity to &lt;code class=&quot;highlighter-rouge&quot;&gt;0.6&lt;/code&gt; so the map is a bit less noisy.&lt;/p&gt;

&lt;h3 id=&quot;crop-and-convert-the-vector-data&quot;&gt;Crop and convert the vector data&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;OGR2GMT:=ogr2ogr -f GMT -spat $(XMIN) $(YMIN) $(XMAX) $(YMAX) -clipsrc spat_extent

build/flowline.gmt: water/Shape/NHDFlowline.shp
	$(OGR2GMT) $@ $&amp;lt; 

build/waterbody.gmt: water/Shape/NHDWaterbody.shp
	$(OGR2GMT) $@ $&amp;lt; 

build/roads.shp: $(wildcard roads/Shape/Trans_RoadSegment*.shp)
	ogr2ogr -f 'ESRI Shapefile' -spat $(XMIN) $(YMIN) $(XMAX) $(YMAX) -clipsrc spat_extent $@ $(word 1,$^)
	ogr2ogr -f 'ESRI Shapefile' -spat $(XMIN) $(YMIN) $(XMAX) $(YMAX) -clipsrc spat_extent -addfields $@ $(word 2,$^)
	ogr2ogr -f 'ESRI Shapefile' -spat $(XMIN) $(YMIN) $(XMAX) $(YMAX) -clipsrc spat_extent -addfields $@ $(word 3,$^)

build/roads.gmt: build/roads.shp
	ogr2ogr -f GMT $@ $&amp;lt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Creating flowline (streams) and waterbody (lakes, etc) vectors is a simple matter of cropping the source data with &lt;code class=&quot;highlighter-rouge&quot;&gt;ogr2ogr&lt;/code&gt; and writing it out in the GMT format.
Creating the roads file is a bit more tricky, since the road data comes in three seperate shapefiles.
I wasn’t able to figure out how to &lt;code class=&quot;highlighter-rouge&quot;&gt;-addfields&lt;/code&gt; to a GMT vector file, so I create an intermediate &lt;code class=&quot;highlighter-rouge&quot;&gt;build/roads.shp&lt;/code&gt;, then convert that file to gmt.&lt;/p&gt;

&lt;h3 id=&quot;create-a-color-palette&quot;&gt;Create a color palette&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;build/slope.cpt: Makefile
	makecpt -Cwhite,'#ffff33','#ff7f00','#e41a1c','#984ea3','#377eb8','#777777' -T0,25,30,35,40,45,50,90 -N &amp;gt; $@
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This rule creates a color palette that we’ll use for our slopes.&lt;/p&gt;

&lt;h2 id=&quot;putting-it-all-together&quot;&gt;Putting it all together&lt;/h2&gt;

&lt;p&gt;Now that we’ve created all of the intermediate products, let’s rewrite our PostScript rule to create our final map.
I’ll step through the rule components one-by-one, with an explanation immediately after.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;build/hidden-valley.ps: build/dem.tif build/slope.nc build/gradient.nc build/flowline.gmt build/waterbody.gmt build/roads.gmt build/slope.cpt Makefile
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Add all of our derivative products to ensure they get built.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	grdimage build/slope.nc -Cbuild/slope.cpt -Ibuild/gradient.nc -Ba -B+t&quot;Hidden Valley&quot; -JM8i -Rbuild/slope.nc -K &amp;gt; $@
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Draw the slope grid, colored with our custom palette.
The &lt;code class=&quot;highlighter-rouge&quot;&gt;-JM8i&lt;/code&gt; specifies the projection for these data, in this case a Mercator projection that is 8 inches wide.
The &lt;code class=&quot;highlighter-rouge&quot;&gt;-R&lt;/code&gt; instructs &lt;code class=&quot;highlighter-rouge&quot;&gt;grdimage&lt;/code&gt; to use the bounds of the &lt;code class=&quot;highlighter-rouge&quot;&gt;build/slope.nc&lt;/code&gt; grid as the bounds of the plot.
The &lt;code class=&quot;highlighter-rouge&quot;&gt;-I&lt;/code&gt; option adds the hillshade, the &lt;code class=&quot;highlighter-rouge&quot;&gt;-Ba&lt;/code&gt; adds a border, the &lt;code class=&quot;highlighter-rouge&quot;&gt;-B+t&lt;/code&gt; titles the plot.
The &lt;code class=&quot;highlighter-rouge&quot;&gt;-K&lt;/code&gt; option “keeps the output file open” so we can add more layers.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	grdcontour build/dem.tif -C20 -A100 -J -R -K -O &amp;gt;&amp;gt; $@
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Add contours spaced 20 meters apart, labelled every 100 meters.
The &lt;code class=&quot;highlighter-rouge&quot;&gt;-J&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;-R&lt;/code&gt; options inherit the values used in the previous command, so we don’t need to specify them again.
The &lt;code class=&quot;highlighter-rouge&quot;&gt;-O&lt;/code&gt; option instructs &lt;code class=&quot;highlighter-rouge&quot;&gt;grdcontour&lt;/code&gt; to output “overlay” PostScript that is meant to be appended onto PostScript data “kept open” with &lt;code class=&quot;highlighter-rouge&quot;&gt;-K&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	psxy build/flowline.gmt -W0.6p,'#377eb8' -J -R -K -O &amp;gt;&amp;gt; $@
	psxy build/waterbody.gmt -G'#377eb8' -J -R -K -O &amp;gt;&amp;gt; $@
	psxy build/roads.gmt -W1p,'#f781bf' -J -R -K -O &amp;gt;&amp;gt; $@
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Add the vector data.
The &lt;code class=&quot;highlighter-rouge&quot;&gt;-W&lt;/code&gt; option specifies the pen used to draw lines, and the &lt;code class=&quot;highlighter-rouge&quot;&gt;-G&lt;/code&gt; option specifies the fill.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	psbasemap -Lx5.2i/-0.7i+c$(YMIN)+w1k -J -R -K -O &amp;gt;&amp;gt; $@
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Add the length scale, set to 1km.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	psscale -D0i/-0.7i+w3i/0.2i+h -Cbuild/slope.cpt -G0/60 -By+l&quot;Slope angle&quot; -I -O &amp;gt;&amp;gt; $@
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Add the color legend.&lt;/p&gt;

&lt;p&gt;Now you can run &lt;code class=&quot;highlighter-rouge&quot;&gt;make build/hidden-valley.png&lt;/code&gt; and get your map!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/hidden-valley-slope-angle.png&quot; alt=&quot;Hidden Valley&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;By automating this map-generation, you can easily create maps for new areas.
I’ve souped up this example into &lt;a href=&quot;https://github.com/gadomski/slope-maps&quot;&gt;this project&lt;/a&gt;, which I can use to quickly create maps of new areas I’m exploring.&lt;/p&gt;

&lt;p&gt;Here’s the complete Makefile used for this example, along with a download script to grab the data you need:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/gadomski/f90e464114e5bbfecdda9e6b262f5adf.js&quot;&gt; &lt;/script&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;

&lt;ol class=&quot;bibliography&quot;&gt;&lt;li&gt;&lt;span id=&quot;McClung2006&quot;&gt;McClung, D., &amp;amp; Schaerer, P. (2006). &lt;i&gt;The Avalanche Handbook&lt;/i&gt; (3rd ed.). The Mountaineers Books.&lt;/span&gt;&lt;/li&gt;&lt;/ol&gt;</content><category term="gmt" /><category term="gmt" /><category term="slope-map" /><category term="ogr" /><category term="gdal" /><category term="skiing" /><category term="hidden-valley" /><summary type="html">About two-thirds of dry slab avalanches occur on slopes between 30° and 45° (McClung &amp;amp; Schaerer, 2006).
A map of slope angles is therefore a useful tool for safe decision making when backcountry skiing.</summary></entry><entry><title type="html">cpd v0.5.0</title><link href="http://www.gadom.ski/2017/01/23/cpd-v0-5-0.html" rel="alternate" type="text/html" title="cpd v0.5.0" /><published>2017-01-23T00:00:00-07:00</published><updated>2017-01-23T00:00:00-07:00</updated><id>http://www.gadom.ski/2017/01/23/cpd-v0-5-0</id><content type="html" xml:base="http://www.gadom.ski/2017/01/23/cpd-v0-5-0.html">&lt;p&gt;I’m happy to announce the release of &lt;a href=&quot;https://github.com/gadomski/cpd/releases/tag/v0.5.0&quot;&gt;cpd v0.5.0&lt;/a&gt;, as well as the associated &lt;a href=&quot;https://github.com/PDAL/PDAL/pull/1474&quot;&gt;PDAL plugin update&lt;/a&gt;.
&lt;strong&gt;cpd&lt;/strong&gt; is a C++ library I have developed for running the &lt;a href=&quot;https://sites.google.com/site/myronenko/research/cpd&quot;&gt;Coherent Point Drift&lt;/a&gt; (CPD) point cloud change detection algorithm.&lt;/p&gt;

&lt;p&gt;One of my research areas is whether CPD is a viable tool for point cloud change detection and registration as compared to existing methods. 
One place where I’ve used &lt;strong&gt;cpd&lt;/strong&gt; is with repeat LiDAR scans to measure glacier velocity, e.g. at the Helheim Glacier in southeast Greenland:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/helheim-velocity-field.png&quot; alt=&quot;Helheim velocity field&quot; /&gt;&lt;/p&gt;

&lt;p&gt;There’s a lot of space and work to be done with CPD, and at this point I’m just scratching that ol’ surface.
But the &lt;strong&gt;cpd&lt;/strong&gt; codebase is reaching, if not maturity, then the equivalent of its early twenties, so I’m hopeful that I will be able to slow down on direct development and focus more on applications and downstream science.&lt;/p&gt;

&lt;p&gt;The PDAL plugin in pretty limited, and it this point exists mostly as a proof-of-concept. 
Rather than use it directly, I usually create a new project (e.g. &lt;a href=&quot;https://github.com/gadomski/hunky-dory&quot;&gt;hunky-dory&lt;/a&gt;) for a specific use-case.
However, the plan is to eventually roll all of my external change detection projects back into PDAL once my tools mature enough that I won’t be over-churning the PDAL codebase.
At that point, the PDAL &lt;strong&gt;cpd&lt;/strong&gt; plugin should become more powerful; it might even evolve into a higher-level &lt;strong&gt;changes&lt;/strong&gt; plugin that can run multiple change detection algorithms, e.g. &lt;a href=&quot;https://en.wikipedia.org/wiki/Iterative_closest_point&quot;&gt;ICP&lt;/a&gt;.
Stay tuned.&lt;/p&gt;</content><category term="cpd" /><category term="pdal" /><summary type="html">I’m happy to announce the release of cpd v0.5.0, as well as the associated PDAL plugin update.
cpd is a C++ library I have developed for running the Coherent Point Drift (CPD) point cloud change detection algorithm.</summary></entry><entry><title type="html">cpd v0.5.0</title><link href="http://www.gadom.ski/cpd/2017/01/20/cpd-v0-5-0.html" rel="alternate" type="text/html" title="cpd v0.5.0" /><published>2017-01-20T00:00:00-07:00</published><updated>2017-01-20T00:00:00-07:00</updated><id>http://www.gadom.ski/cpd/2017/01/20/cpd-v0-5-0</id><content type="html" xml:base="http://www.gadom.ski/cpd/2017/01/20/cpd-v0-5-0.html">&lt;p&gt;I’m happy to announce the release of &lt;a href=&quot;https://github.com/gadomski/cpd/releases/tag/v0.5.0&quot;&gt;cpd v0.5.0&lt;/a&gt;, as well as the associated &lt;a href=&quot;https://github.com/PDAL/PDAL/pull/1474&quot;&gt;PDAL plugin update&lt;/a&gt;.
&lt;strong&gt;cpd&lt;/strong&gt; is a C++ library I have developed for running the &lt;a href=&quot;https://sites.google.com/site/myronenko/research/cpd&quot;&gt;Coherent Point Drift&lt;/a&gt; (CPD) point cloud change detection algorithm.&lt;/p&gt;

&lt;p&gt;One of my research areas is whether CPD is a viable tool for point cloud change detection and registration as compared to existing methods. 
One place where I’ve used &lt;strong&gt;cpd&lt;/strong&gt; is with repeat LiDAR scans to measure glacier velocity, e.g. at the Helheim Glacier in southeast Greenland:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/helheim-velocity-field.png&quot; alt=&quot;Helheim velocity field&quot; /&gt;&lt;/p&gt;

&lt;p&gt;There’s a lot of space and work to be done with CPD, and at this point I’m just scratching that ol’ surface.
But the &lt;strong&gt;cpd&lt;/strong&gt; codebase is reaching, if not maturity, then the equivalent of its early twenties, so I’m hopeful that I will be able to slow down on direct development and focus more on applications and downstream science.&lt;/p&gt;

&lt;p&gt;The PDAL plugin in pretty limited, and it this point exists mostly as a proof-of-concept. 
Rather than use it directly, I usually create a new project (e.g. &lt;a href=&quot;https://github.com/gadomski/hunky-dory&quot;&gt;hunky-dory&lt;/a&gt;) for a specific use-case.
However, the plan is to eventually roll all of my external change detection projects back into PDAL once my tools mature enough that I won’t be over-churning the PDAL codebase.
At that point, the PDAL &lt;strong&gt;cpd&lt;/strong&gt; plugin should become more powerful; it might even evolve into a higher-level &lt;strong&gt;changes&lt;/strong&gt; plugin that can run multiple change detection algorithms, e.g. &lt;a href=&quot;https://en.wikipedia.org/wiki/Iterative_closest_point&quot;&gt;ICP&lt;/a&gt;.
Stay tuned.&lt;/p&gt;</content><category term="cpd" /><category term="cpd" /><category term="pdal" /><summary type="html">I’m happy to announce the release of cpd v0.5.0, as well as the associated PDAL plugin update.
cpd is a C++ library I have developed for running the Coherent Point Drift (CPD) point cloud change detection algorithm.</summary></entry><entry><title type="html">Cropping and merging with PDAL</title><link href="http://www.gadom.ski/pdal/2017/01/19/cropping-and-merging-with-pdal.html" rel="alternate" type="text/html" title="Cropping and merging with PDAL" /><published>2017-01-19T15:00:00-07:00</published><updated>2017-01-19T15:00:00-07:00</updated><id>http://www.gadom.ski/pdal/2017/01/19/cropping-and-merging-with-pdal</id><content type="html" xml:base="http://www.gadom.ski/pdal/2017/01/19/cropping-and-merging-with-pdal.html">&lt;p&gt;This is the first in a series of posts describing how to use &lt;a href=&quot;http://www.pdal.io/&quot;&gt;PDAL&lt;/a&gt; to develop automated, repeatable processes, the kind that can be tedious to do manually in &lt;a href=&quot;http://www.riegl.com/products/software-packages/riscan-pro/&quot;&gt;RiSCAN Pro&lt;/a&gt; or other such software.
These posts are aimed at a medium-to-high-level user, one who is comfortable with the command line, writing makefiles, and basic scripting.
The PDAL &lt;a href=&quot;http://www.pdal.io/tutorial/index.html&quot;&gt;tutorials&lt;/a&gt; and &lt;a href=&quot;http://www.pdal.io/workshop/index.html&quot;&gt;workshop&lt;/a&gt; might be a better start for a beginner user.&lt;/p&gt;

&lt;p&gt;You’ll need the following softwares for this exercise:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.pdal.io/&quot;&gt;PDAL&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://gdal.org/1.11/ogr/&quot;&gt;OGR&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.python.org/&quot;&gt;Python&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;the-problem&quot;&gt;The problem&lt;/h2&gt;

&lt;p&gt;Given data from five terrestrial laser scanning (TLS) scan positions, crop the data to an area of interest (AOI) and provide those cropped data to the downstream user as a single file.&lt;/p&gt;

&lt;p&gt;About as simple as it gets.&lt;/p&gt;

&lt;p&gt;The data of interest were collected with a &lt;a href=&quot;http://www.riegl.com/nc/products/terrestrial-scanning/produktdetail/product/scanner/33/&quot;&gt;Riegl VZ-6000&lt;/a&gt; on May 01, 2013 in the Tuolumne Meadows area of Yosemite National Park in California.
Not bad livin’:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2013-05-01-tuolumne.jpg&quot; alt=&quot;Tuolumne Meadows&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The area of interest is a rectangular box in the east side of the meadow, south of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Lembert_Dome&quot;&gt;Lembert Dome&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2013-05-01-tuolumne-aoi.png&quot; alt=&quot;Area of interest&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note: there were actually six scan positions collected that day, but ScanPos006 did not contain any useful data inside the area of interest, so we’ve not included it in this exercise other than to plot it on the above map.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;the-process&quot;&gt;The process&lt;/h2&gt;

&lt;p&gt;We pick things up after we’ve exported a file for each scan position from RiSCAN Pro.
We could have used PDAL to do the exporting, but that’s a more advanced subject for a later day.
I’ve organized the laz files and our AOI shapefile like this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ tree .
.
├── Makefile
├── aoi
│   ├── study_area1.dbf
│   ├── study_area1.gmt
│   ├── study_area1.prj
│   ├── study_area1.shp
│   └── study_area1.shx
└── laz
    └── original
        ├── ScanPos001.laz
        ├── ScanPos002.laz
        ├── ScanPos003.laz
        ├── ScanPos004.laz
        └── ScanPos005.laz
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;We’ll use that &lt;code class=&quot;highlighter-rouge&quot;&gt;Makefile&lt;/code&gt; to drive our processing.&lt;/p&gt;

&lt;h3 id=&quot;cropping&quot;&gt;Cropping&lt;/h3&gt;

&lt;p&gt;We’re going to crop the data with &lt;a href=&quot;http://www.pdal.io/stages/filters.crop.html&quot;&gt;PDAL’s crop filter&lt;/a&gt; by providing it a &lt;a href=&quot;https://en.wikipedia.org/wiki/Well-known_text&quot;&gt;WKT&lt;/a&gt; polygon of our AOI.
Because our AOI is a shapefile, we need to convert it to WKT with &lt;a href=&quot;http://www.gdal.org/ogr2ogr.html&quot;&gt;ogr2ogr&lt;/a&gt;.
Since shapefiles can be complicated, there’s no straightforward way to convert a shapefile to WKT; in this case, however, we know that our shapefile is simple enough to use this simple Python script, located in &lt;code class=&quot;highlighter-rouge&quot;&gt;~/bin/ogr2wkt&lt;/code&gt; (which is on my &lt;code class=&quot;highlighter-rouge&quot;&gt;$PATH&lt;/code&gt;):&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;#!/usr/bin/env python&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;sys&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;osgeo&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ogr&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;ERROR: invalid number of arguments&quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ogr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;feature&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetLayer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;feature&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetGeometryRef&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ExportToWkt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We glue everything together with a couple of make rules (in &lt;code class=&quot;highlighter-rouge&quot;&gt;Makefile&lt;/code&gt;):&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;CROPPED&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;patsubst laz/original/%.laz,las/cropped/%.laz,&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;wildcard laz/original/&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;.laz&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;SRS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;EPSG:32611

&lt;span class=&quot;nl&quot;&gt;cropped&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;$(CROPPED)&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;.PHONY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;cropped&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;laz/cropped/%.laz&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;laz/original/%.laz aoi/study_area1.shp&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;pdal&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;translate&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-i&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&amp;lt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$@&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;--readers.las.spatialreference&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$(SRS)&lt;/span&gt; -f crop --filters.crop.polygon&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;shell&lt;/span&gt; ogr2wkt &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;word 2,&lt;span class=&quot;nv&quot;&gt;$^))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;RiSCAN Pro doesn’t export laz data with spatial reference information (at least, it doesn’t without diving deep into their GeoSysManager, which I’ve never found worth it).
So we manually specify the source spatial reference system with &lt;code class=&quot;highlighter-rouge&quot;&gt;--readers.las.spatialreference&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We can use make’s parallelization to process all the files at once:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ make -j 5 cropped
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Boom.
We’ve got five cropped laz files in &lt;code class=&quot;highlighter-rouge&quot;&gt;las/cropped&lt;/code&gt;, taking advantage of multiple cores.&lt;/p&gt;

&lt;h3 id=&quot;merging&quot;&gt;Merging&lt;/h3&gt;

&lt;p&gt;Merging these cropped files into one big deliverable is even simpler with &lt;code class=&quot;highlighter-rouge&quot;&gt;pdal merge&lt;/code&gt;.
I still like to use a make rule, for repeatability:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;laz/2013-05-01-StudyArea1.laz: $(CROPPED)
    pdal merge $^ $@
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Our tree should now look like this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ tree .
.
├── Makefile
├── aoi
│   ├── study_area1.dbf
│   ├── study_area1.gmt
│   ├── study_area1.prj
│   ├── study_area1.shp
│   └── study_area1.shx
└── laz
    ├── 2013-05-01-StudyArea1.laz
    ├── cropped
    │   ├── ScanPos001.laz
    │   ├── ScanPos002.laz
    │   ├── ScanPos003.laz
    │   ├── ScanPos004.laz
    │   └── ScanPos005.laz
    └── original
        ├── ScanPos001.laz
        ├── ScanPos002.laz
        ├── ScanPos003.laz
        ├── ScanPos004.laz
        └── ScanPos005.laz
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;While it’s not hard to do this sort of work in a GUI, things get harder when you want to do the same process over and over, tweaking the inputs, or you want to do the work on a large number of files.
Automation such as this is also handy when integrating with other processing steps, such as map generation.&lt;/p&gt;</content><category term="pdal" /><category term="pdal" /><category term="ogr" /><category term="python" /><summary type="html">This is the first in a series of posts describing how to use PDAL to develop automated, repeatable processes, the kind that can be tedious to do manually in RiSCAN Pro or other such software.
These posts are aimed at a medium-to-high-level user, one who is comfortable with the command line, writing makefiles, and basic scripting.
The PDAL tutorials and workshop might be a better start for a beginner user.</summary></entry></feed>
